原型
  它是构造函数造成的对象的公共祖先,当你不给原型设置值的时候它的prototype就指向一个空对象,通过这个构造函数产生的对象,可以继承它原先的属性和方法,原型也是一个对象

  构造函数产生的对象可以继承构造函数原型的属性,但是如果自己也有那个属性,那就不会去继承了

  构造函数产生的对象不一定不能修改它构造函数的原型的属性,如果你修改的是引用值,那么就可以修改

  构造函数产生的对象也不能给构造函数的原型增加东西

__proto__
  它是一个隐式的属性
  构造函数产生的对象和构造函数的prototype就是通过__proto__产生的连接

__proto__和prototype的区别
  protoptype是构造函数用来查看原型的工具
  构造函数产生的对象可以通过__proto__来查看构造出自己的构造函数的原型

constructor
   构造器的意思,构造函数构造出来的对象通过它来查看构造自己的函数
   constructor定义在了原型上

原型链
  但凡你是对象你就有原型,原型也是一个对象,所以它也有原型,绝大多少的原型链的终点是Object.prototype

  原型链是一层一层的,自己没有找构造函数的原型,构造函数的原型没有,就继续往上找,找到最后如果没有那么就返回undefined

  有原型就一定有原型链

Object.create()
  这个括号里面要写的是你想要的原型,括号当中不能写原始值,非对象的值都不能填,但是null除外,写null会导致你找不到原型了

  你想手动干预一个构造函数的原型让它是null,但是最后还是会有原型,也就是说无法手动干预

  并不是所有对象都有原型 

当你想用document.write去访问一个var obj = {}；它会隐式的调用obj的原型Object.prototype里面的toString方法

<!-- 闭包的私有化变量       有问题 -->

call和apply
  改变函数执行时的this指向问题

  call括号里面写的是什么,那么this就变成谁,call的第二个形参对应的是第一个实参,括号里面的第一位就是改变this指向的,后边的按位传

  call和apply区别在传参列表不同,apply哪怕只传一个参数,那也要用数组形式,剩下的完全一致没有区别

  apply用的多,因为大多数时候你不知道你要传多少参数,这时候就可以用apply(obj,arguments),arguments本身就是一个数组集合,所以用arguments就可以

  call和apply就相当于去找代工厂

继承发展史
  1.传统形式,原型链继承,该方法不好的点在于,它是运用链式继承,需要一级一级往上找,就会导致继承过多没有用的属性
  
  2.借用构造函数,就相当于借用工厂函数里面的方法来丰满自己,用工厂.call的方法,并不能算是真正的继承

  3.共享原型,让两个构造函数拥有一个原型

  4.圣杯模式,经过了一个版本的改变,这会再在target原型里面添加一个属性就不会影响origin的原型了,因为创造了一个中间人(也就是另外一个构造函数),我要继承的东西我能拿过来,我要给自己增加的东西我依然能添加,就这就是最终模式

命名空间
  根本目的:管理变量,防止污染全局,适用于模块开发

为了防止命名冲突的方式,我们就会定义一个大对象,然后在对象里面,再设置一个对象,然后进行调用最里面这个对象

实现链式调用
  就是在每执行过一次后都在对象内部return this,也就是返回自己,你都把自己返回了那下一次就一定可以再调用

this    *************************************
  1.在预编译的时候函数自执行输出他的this指向的就是window
  
  2.如果在全局作用域当中定义一个this,那它返回的指也是window

  3.call和apply可以改变this的指向

  4.谁调用的this就指向谁,比如obj.func() ,这里面的this就指向的是obj
   
属性的表示方法
  当你写obj.name 在浏览器里面的时候,系统会自动给你变成obj[name]

对象的枚举
  for in循环,它的执行次数取决于in后面的对象有多少属性,有多少属性就执行多少次,in每次在对象里面拿出来一个属性就会赋值给prop,for in只遍历对象里面的属性,for in循环会把你定义的原型也打印出来,但是原型的原型不会打印出来

hasownProperty
  用来过滤掉自己的原型上的属性

in操作符
  用来判断当前属性是不是in后面的对象里面的属性,如果是那么就返回布尔值,
  切记in前面的属性要用字符串形式
  缺点就是当你用in运算符的时候,它会把原型链上面的也拿出来比较,它切实只能判断你这个对象能不能访问到这个属性,但是不会管你,你到底是不是这个对象的

instanceof
  a instanceof b 判断a的原型链上,有没有b的原型

constructor和instancof可以区分object和array
因为arr的constructor是function Array
 object的constructor是function Object
instancof是因为obj的原型上没有array

Array/Number/Boolean/String,他们上边都有toString方法
toString就是为了方便打印各种类型的，所以在各种类型当中都有toString方法


