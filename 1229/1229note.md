                                                     立即执行函数
                    
                    读到它这立即被执行，执行完立即被销毁
                    写法：
                         （function （） {

                         } （） ）
                            | 
                             这个小括号里面用来传形参值,这个小括号放里面放外面都可以
                             这种是W3C规范

                            
                    1.函数声明，不能被直接执行
                    2.能被执行符（）；执行的必须是表达式

                    立即执行函数里面,也有执行上下文,也会有闭包,他是先销毁执行上下文然后函数本身也被销毁了
                    连续返回依然形成闭包,越里层的闭包危害越大


                                                    逗号运算符
                    返回逗号后面那个

                    如何防治闭包:
                                与外面的函数形成一对一闭包

                    闭包的防范:
                              闭包会导致多个执行函数共用一个公有变量,如果不是特殊需要,应尽量防止这种情况发生.




                                                  js运行三部曲
                    
                    语法分析：
                             不执行你程序但是通篇扫描一遍看你程序格式有没有错
                    预编译：
                            发生在执行之前,主要解决命名冲突，以及执行顺序的问题，预编译产生执行期上下文，函数执行封面了执行期上下文
                    解释执行


                    imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有。 也就是归window所有

                    一切声明的全局变量，全是window的属性

                    var a = 123; ===> window.a = 123;


                    执行期上下文   英文名字：Activation Object -->AO


                    预编译四部曲：
                                1.创建AO对象
                                2.找形参和变量声明，将变量和形参作为AO属性名，值为undefined
                                3.将实参值和形参统一
                                4.在函数体里面找函数声明，值赋予函数体

                    这四部都结束之后按照执行来设置ao

                    (当全局变量预编译时候，就第2部和第4部)
                    变量声明提示
                    函数声明整体提升

                    在浏览器环境下，GO其实就是window
                    在nodeJS环境下，GO其实是global


                    js的垃圾回收机制

                JavaScript具有垃圾收集器，垃圾收集器会按照固定的时间间隔周期性的执行。
                有两种最常见的垃圾回收方式：
                                         1.标记清除
                                         2.引用计数

                标记清除：
                        原理:是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。
                        1.垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。
                        2.去掉环境中的变量以及被环境中的变量引用的变量的标记。
                        3.再被加上标记的会被视为准备删除的变量。
                        4.垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。

                引用计数：
                        原理:跟踪记录每个值被引用的次数。
                        1.声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。
                        2.同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。
                        3.当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1。
                        4.当引用次数变成0时，说明没办法访问这个值了。
                        5.当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。