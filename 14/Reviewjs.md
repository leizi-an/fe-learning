执行期上下文
    当一个函数在执行的时候,会自己产生一个叫做执行期上下文的内部对象,一个执行期上下文定义了一个函数执行时的环境,函数每次执行的时候所产生的执行器上下文都不一样,是独一无二的,所以当你多次调用一个函数的时候,它会产生很多执行期上下文,当函数执行结束的时候,它所产生的执行器上下文也会被销毁.

作用域
    作用域分为全局和局部作用域
    全局作用域也就是定义在了最外面,谁都可以访问,而且通篇都可以应用
    局部作用域,只有在变量定义的范围内可用

作用域链
    多个作用域嵌套起来就形成了作用域链,里层的作用域可以访问外层,但是外层的不可以访问里层

如何查找变量
    从作用域链的顶端往下找

当函数执行完毕,它所产生的执行期上下文一定被销毁 
    a 定义 0.GO {}
    a 执行 0.AO {}   1.GO {}
    a 执行结束 0.GO{}        //这一步是因为,每次执行都会产生新的执行期上下文,当执行结束的时候,刚刚的执行期上下文就销毁了
    a 再次执行 0.AO {} 1.GO {}     //这里的ao是新产生的
    a 执行结束 0.GO {}

每当一个函数执行的时候,都会产生新的执行期上下文,新产生的执行期上下文都跟之前的不一样

闭包 
   闭包产生的原因就是因为有作用域链的存在,外层作用域无法访问里层作用域,我们又想让外层的访问到里层的,所以就要用到一个函数嵌套的方法,把里面的函数返回到外层,这样就可以达到在外面访问的目的

当产生闭包的时候,会导致原理的作用域没有得到释放,会造成内存泄漏

内存泄漏
   内存剩的越来越少了,叫做内存泄漏,泄漏关注的不是漏的过程,关注的是内存剩余的过程

立即执行函数
   立即执行函数就是,读到该函数的时候,立即就执行该函数,执行完立刻销毁
   (function () {

   } ())
   这最后一个小括号里面用来传形参值,小括号放里面还是我们都行,w3c的规范是放里面

立即执行函数可以解决闭包问题

如何防范闭包,那就是与外面的函数形成一对一闭包

立即执行函数当中也有执行上下文,也会产生闭包,他是先销毁执行期上下文,然后再销毁函数本身

越是位于里层的闭包,产生的内存泄漏问题越严重

一个普通的函数声明不能执行,要想被执行必须是执行一个表达式

逗号运算符
    返回逗号后面的那个

    imply global 指的是全局变量,如果变量未经声明就赋值,那么此变量就会归全局对象所有,也就是归widow所有

js运行三部曲
    语法分析
        不执行程序,但是会通篇检查一下看你程序的格式有没有错误
    预编译
        在执行之前进行的,主要为了解决命名冲突,执行顺序,预编译会产生执行期上下文,函数的执行结束了执行期上下文
    解释执行

预编译的四部曲
      1.创建一个AO对象
      2.找形参和变量声明,将变量和形参作为AO的属性名,值为undefined
      3.将实参和形参统一
      4.在函数体里面找函数声明,值赋给函数体

当着四步结束之后,我们就按照执行时的赋值情况来改变AO

当全局变量预编译的时候,只有就有2和4两部操作

在预编译的时候有两个提升
       1.变量声明提升
       2.函数声明提升

在浏览器环境下,GO其实就是window
在nodejs环境下,GO其实是global

js的垃圾回收机制
     JavaScript具有垃圾收集器，垃圾收集器会按照固定的时间间隔周期性的执行

有两种最常见的垃圾回收机制
           1.标记清除
           2.引用计数

标记清除
    原理:
    当变量进入环境的时候,将这个变量标记为"进入环境",当变量离开环境时,就把它标记成"离开环境",最后将标记成离开环境的回收内存
    1.垃圾回收器,在运行的时候会给所有变量都标上一个标记
    2.去掉环境中的变量,以及被环境中变量调用的变量的标记
    3.再被加上标记的被记为准备删除的变量
    4.垃圾回收器,完成内存清除工作,销毁那些带标记的值,并回收他们所占用的内存空间

引用计数
    原理:
    跟踪记录每个值被引用的次数
    1.声明一个变量并将一个引用类型的值赋给这个变量,这个引用类型值的引用次数就是1
    2.同一个值又被赋给另一个变量,这个引用类型的值的引用次数加一
    3.当包含这个引用类型值的变量又被赋值成另一个值了,那么这个引用值类型值的引用次数减1
    4.当引用次数变成0,说明没办法访问这个值
    5.当垃圾收集器下一次运行,它就会释放引用次数是0的值所占的内存

对象
  对象的创建方法
    1.对象字面量,也叫直接量
     var obj() {

     }

    2.var obj = new Object();
    第二种方法是通过系统的构造函数,生产一个对象
    new就是一个按钮,按一下就会生产出一个对象

    3.自定义
    function Person() {

    }
    var person = new Person();

构造函数跟函数长得一模一样,所以在定义构造函数的时候,为了区分,就要求在写构造函数名的时候要使用大驼峰式命名： TheFirstName

构造函数的内部原理
     系统会隐式的给你写一行 var this = {};
     在最后还好隐式的给你写一个return this;
     如果你显示的写了一个return 123;
     那么会忽略你写的这个return继续返回那个隐式的this,因为系统不会让你返回一个原始值,但如果你写的是 return that,那么就会乖乖的返回that

包装类
    var str = new String('abcd');
    var num = new Number(123);
    var boo = new Boolean(true);
    系统会隐式的调用他们
    原始值无论能不能赋值,最后都会返回出来undefined

    当你想判断 undefined == null  返回结果是true
    0 和 undefined 和null不相等   结果是false



         



